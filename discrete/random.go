package discrete

import (
	"fmt"
	"math/rand"

	"github.com/gustavooferreira/prometheus-metrics-generator/metrics"
)

// RandomDataGeneratorOptions contains the options for the RandomDataGenerator.
type RandomDataGeneratorOptions struct {
	// AmplitudeMax represents the maximum value the data iterator will return.
	AmplitudeMax float64
	// AmplitudeMin represents the minimum value the data iterator will return.
	AmplitudeMin float64

	// IterationCountLimit sets the number of iterations to be used by the segment.
	IterationCountLimit int
}

// Check at compile time whether RandomDataGenerator implements DataGenerator interface.
var _ DataGenerator = (*RandomDataGenerator)(nil)

// RandomDataGenerator returns a DataIterator representing a random sequence of samples.
// Note that it's an error to use negative values with counters. It's the user responsibility to make sure negative
// numbers only appear in gauges.
// The data series generated by this function must be finite. A perpetual series can be created by setting the
// EndStrategy in the series.Series struct to loop over forever.
// The generated series when using the LengthDuration setting will be inclusive by default. This means that if the
// scrape time coincides with the time at which the LengthDuration would be computed at, the scrape will still be
// generated.
// For example, if there is a scrape interval of 15 seconds and the LengthDuration is set to be 1 minute, then the data
// iterator will return 5 data points, not 4!
// If that's not the desired behaviour, make sure to set LengthDurationExclusive setting to true.
// The zero value is not useful.
type RandomDataGenerator struct {
	options RandomDataGeneratorOptions
}

// NewRandomDataGenerator returns a new instance of RandomDataGenerator.
func NewRandomDataGenerator(options RandomDataGeneratorOptions) (*RandomDataGenerator, error) {
	if options.IterationCountLimit <= 0 {
		return &RandomDataGenerator{}, fmt.Errorf("iteration count limit cannot be less than or equal to zero")
	}

	return &RandomDataGenerator{
		options: options,
	}, nil
}

func (r *RandomDataGenerator) Iterator() metrics.DataIterator {
	return &RandomDataIterator{
		random: *r,
	}
}

func (r *RandomDataGenerator) Describe() DataSpec {
	return DataNodeDataSpec{
		name: "Random",
	}
}

// Check at compile time whether RandomDataIterator implements metrics.DataIterator interface.
var _ metrics.DataIterator = (*RandomDataIterator)(nil)

type RandomDataIterator struct {
	// read-only access
	random RandomDataGenerator

	// iterCount represents the cycle the iterator is in
	iterCount int
}

// Evaluate fulfills the metrics.DataIterator interface.
// This function is responsible for returning the data points one at a time.
func (ri *RandomDataIterator) Evaluate(scrapeInfo metrics.ScrapeInfo) metrics.ScrapeResult {
	// Have we reached the end?
	if ri.iterCount >= ri.random.options.IterationCountLimit {
		return metrics.ScrapeResult{Exhausted: true}
	}

	// Make sure to increment the iterator counter before leaving the function
	defer func() { ri.iterCount++ }()

	randomValue := rand.Float64()*(ri.random.options.AmplitudeMax-ri.random.options.AmplitudeMin) +
		ri.random.options.AmplitudeMin
	return metrics.ScrapeResult{Value: randomValue}
}
