package continuous

import (
	"fmt"
	"time"

	"github.com/gustavooferreira/prometheus-metrics-generator/metrics"
)

// Check at compile time whether LinearSegmentDataIterator implements DataIterator interface.
var _ DataIterator = (*LinearSegmentDataIterator)(nil)

// LinearSegmentDataIterator returns a DataIterator representing a linear segment.
// A linear segment can be horizontal or have a positive or negative slope.
// Linear segments can be put together, with the help of the Join function, to form more complex structures.
// Note that it's an error to use a linear segment containing negative values with counters. It's the user
// responsibility to make sure negative numbers only appear in gauges.
// The data series generated by this function must be finite. A perpetual series can be created by setting the
// EndStrategy in the series.Series struct to loop over forever.
// The generated function will generate values in a closed interval by default. This means that if the scrape time
// coincides with the time of the beginning or end of the function the scrape will still be generated.
// To control whether the interval is open, half-open or closed, use the options IntervalLeftBoundOpen or
// IntervalRightBoundOpen.
// The zero value is not useful.
type LinearSegmentDataIterator struct {
	options LinearSegmentDataIteratorOptions
}

// NewLinearSegmentDataIterator returns a new instance of LinearSegmentDataIterator.
func NewLinearSegmentDataIterator(options LinearSegmentDataIteratorOptions) (*LinearSegmentDataIterator, error) {
	if options.DurationLength < 0 {
		return &LinearSegmentDataIterator{}, fmt.Errorf("duration length cannot be less than or equal to zero")
	}

	return &LinearSegmentDataIterator{
		options: options,
	}, nil
}

// Evaluate computes a sample given a scrape.
func (ls *LinearSegmentDataIterator) Evaluate(scrapeInfo ScrapeInfo) metrics.ScrapeResult {
	// Normalize
	currentElapsedTime := scrapeInfo.IterationTime.Sub(scrapeInfo.FunctionStartTime)

	// Deal with boundaries
	if scrapeInfo.IterationTime.Before(scrapeInfo.FunctionStartTime) { // if before time, return missing
		return metrics.ScrapeResult{Missing: true}
	} else if scrapeInfo.IterationTime.Equal(scrapeInfo.FunctionStartTime) && ls.options.IntervalLeftBoundOpen {
		return metrics.ScrapeResult{Missing: true}
	} else if currentElapsedTime == ls.options.DurationLength && ls.options.IntervalRightBoundOpen {
		return metrics.ScrapeResult{Exhausted: true}
	} else if currentElapsedTime > ls.options.DurationLength { // we are past the duration length for this function
		return metrics.ScrapeResult{Exhausted: true}
	}

	// If we have a horizontal line, there is no need to do any computation
	if ls.options.AmplitudeStart == ls.options.AmplitudeEnd {
		return metrics.ScrapeResult{Value: ls.options.AmplitudeStart}
	}

	slope := (ls.options.AmplitudeEnd - ls.options.AmplitudeStart) / (float64(ls.options.DurationLength))
	value := ls.options.AmplitudeStart + slope*float64(currentElapsedTime)
	return metrics.ScrapeResult{Value: value}
}

// Duration reports the duration of the continuous function.
func (ls *LinearSegmentDataIterator) Duration() time.Duration {
	return ls.options.DurationLength
}

// LinearSegmentDataIteratorOptions contains the options for the LinearSegmentDataIterator.
type LinearSegmentDataIteratorOptions struct {
	// AmplitudeStart represents the initial value for the segment.
	AmplitudeStart float64

	// AmplitudeEnd represents the end value for the segment.
	AmplitudeEnd float64

	// DurationLength sets the max duration between the first and the last value.
	DurationLength time.Duration

	// IntervalLeftBoundOpen specifies whether the left bound of the duration interval should be open.
	// If a scrape time lands on the left bound and this option is set to true, the function will return a missing value.
	IntervalLeftBoundOpen bool

	// IntervalRightBoundOpen specifies whether the right bound of the duration interval should be open.
	// If a scrape time lands on the right bound and this option is set to true, the function will return a missing value.
	IntervalRightBoundOpen bool
}
