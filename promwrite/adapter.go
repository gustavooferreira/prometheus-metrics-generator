package promwrite

import (
	"context"
	"fmt"

	"github.com/gustavooferreira/prometheus-metrics-generator/metrics"
	"github.com/gustavooferreira/prometheus-metrics-generator/promadapter"
)

// Create an adapter, that accepts a scraper and a slice of metrics and does all that we are doing in the main file.
// It just produces all the metrics.

// The adapter should support both buffering and non buffering (i.e., send the metrics directly as soon as we call the
// method to send samples.)

// Scraper is an interface for metrics.Scraper.
type Scraper interface {
	IsInfinite() bool
	Iterator() metrics.ScraperIterator
}

// GenerateAndImportMetrics takes all the samples generated by the DataIterators and sends them to Prometheus.
// prometheusRemoteWriter should be replaced for an interface with a single method: Send()
// Ideally, this function would flush, so we can check if the remoteWriter passed in implements the flush interface
// and if it does, we call flush on it!
// TODO: This function needs to keep track of the time series being generated and in the end send stale markers
// for the time series that didn't mark themselves as stale already!
func GenerateAndImportMetrics(ctx context.Context, prometheusRemoteWriter *PrometheusRemoteWriter, scraper Scraper, metricsObservables []promadapter.MetricObservable) error {
	atLeastOneTimeSeriesIsInfinite := false

	// for all observables, check if any of them has time series that are infinite.
	for _, observable := range metricsObservables {
		if observable.HasInfiniteTimeSeries() {
			atLeastOneTimeSeriesIsInfinite = true
			break
		}
	}

	if atLeastOneTimeSeriesIsInfinite && scraper.IsInfinite() {
		return fmt.Errorf("can't have the scraper and time series being infinite at the same time when using prometheus remote write")
	}

	// we don't want to continue iterating the scraper if there are no more values being generated from any of the
	// timeseries.
	// If this variable is set to true we jump out.
	noMoreSamples := false

	iter := scraper.Iterator()
	for scrapeInfo, ok := iter.Next(); ok && !noMoreSamples; scrapeInfo, ok = iter.Next() {
		noMoreSamples = true

		// for each scrape go through all observables
		for _, observable := range metricsObservables {
			metricResults := observable.Evaluate(scrapeInfo)

			// We have no more metrics to send
			if len(metricResults) == 0 {
				continue
			}

			noMoreSamples = false

			remoteWriterTimeSeries := ConvertToRemoteWriterTimeSeries(observable.Desc().MetricFamily, metricResults)

			fmt.Printf("Time series: %+v\n", remoteWriterTimeSeries)

			err := prometheusRemoteWriter.Send(ctx, remoteWriterTimeSeries)
			if err != nil {
				return fmt.Errorf("error sending metric to prometheus")
			}
		}
	}

	return nil
}
