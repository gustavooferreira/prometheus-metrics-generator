package discrete

import (
	"github.com/gustavooferreira/prometheus-metrics-generator/series"
)

// Check at compile time whether CustomValuesDataGenerator implements DataGenerator interface.
var _ DataGenerator = (*CustomValuesDataGenerator)(nil)

// CustomValuesDataGenerator returns a DataGenerator containing the array of values passed in.
// Each value is returned in sequence on each scrape.
// It won't take time into consideration, simply return the next value when the scrape is performed.
// This means that if the scrape fails, a given value will be returned on the next scrape.
// Note that it's an error to use negative values with counters. It's the user responsibility to make sure negative
// numbers only appear in gauges.
// The data series generated by this function must be finite. A perpetual series can be created by setting the
// EndStrategy in the series.Series struct to loop over forever.
type CustomValuesDataGenerator struct {
	values []CustomValue
}

// NewCustomValuesDataGenerator returns an instance of CustomValuesDataGenerator.
func NewCustomValuesDataGenerator(values []CustomValue) *CustomValuesDataGenerator {
	return &CustomValuesDataGenerator{
		values: values,
	}
}

func (cvdg *CustomValuesDataGenerator) Iterator() DataIterator {
	return &CustomValuesDataIterator{
		customValuesDataGenerator: *cvdg,
	}
}

func (cvdg *CustomValuesDataGenerator) Describe() DataSpec {
	return DataNodeDataSpec{
		name: "Custom Values",
	}
}

// Check at compile time whether CustomValuesDataIterator implements DataIterator interface.
var _ DataIterator = (*CustomValuesDataIterator)(nil)

type CustomValuesDataIterator struct {
	customValuesDataGenerator CustomValuesDataGenerator

	// iterCount represents the cycle the iterator is in
	iterCount int
}

// Iterate fulfills the DataIterator interface.
// This function is responsible for returning the data points one at a time.
func (cvdi *CustomValuesDataIterator) Iterate(scrapeInfo series.ScrapeInfo) series.ScrapeResult {
	// check if index is inside the boundaries, if not, return exhausted
	if cvdi.iterCount >= len(cvdi.customValuesDataGenerator.values) {
		return series.ScrapeResult{Exhausted: true}
	}

	// Make sure to increment the iterator counter before leaving the function
	defer func() { cvdi.iterCount++ }()

	result := cvdi.customValuesDataGenerator.values[cvdi.iterCount]

	return series.ScrapeResult{
		Value:   result.Value,
		Missing: result.Missing,
	}
}

// CustomValue contains the scrape value to be returned by CustomValuesDataIterator.
type CustomValue struct {
	// Value is the value of the sample.
	Value float64

	// Missing indicates whether the scrape failed to retrieve a sample.
	// Used to simulate failed scrapes.
	Missing bool
}
