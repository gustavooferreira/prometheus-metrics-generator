package datafuncs

import (
	"fmt"
	"gustavooferreira/prometheus-metrics-generator/series"
	"time"
)

// LinearSegmentDataIterator returns a DataIterator representing a linear segment.
// A linear segment can be horizontal or have a positive or negative slope.
// Linear segments can be put together, with the help of the Join function, to form more complex structures.
// Note that it's an error to use a linear segment containing negative values with counters. It's the user
// responsibility to make sure negative numbers only appear in gauges.
// The data series generated by this function must be finite. A perpetual series can be created by setting the
// EndStrategy in the series.Series struct to loop over forever.
// The generated series when using the LengthDuration setting will be inclusive by default. This means that if the
// scrape time coincides with the time at which the LengthDuration would be computed at, the scrape will still be
// generated.
// For example, if there is a scrape interval of 15 seconds and the LengthDuration is set to be 1 minute, then the data
// iterator will return 5 data points, not 4!
// If that's not the desired behaviour, make sure to set LengthDurationExclusive setting to true.
func LinearSegmentDataIterator(options LinearSegmentDataIteratorOptions) (series.DataIterator, error) {
	// validation
	if options.LengthDuration == 0 && options.LengthIterationCount == 0 {
		return nil, fmt.Errorf("stop condition needs to be provided, either set the length duration or " +
			"length iteration count")
	}

	if options.LengthDuration != 0 && options.LengthIterationCount != 0 {
		return nil, fmt.Errorf("only one stop condition should be provided")
	}

	if options.LengthDuration < 0 {
		return nil, fmt.Errorf("length duration cannot be negative")
	}

	if options.LengthIterationCount < 0 {
		return nil, fmt.Errorf("length iteration count cannot be negative")
	}

	if options.LengthDurationExclusive && options.LengthDuration == 0 {
		return nil, fmt.Errorf("length duration exclusive option applies to length duration option only, but " +
			"length duration is not set")
	}

	// These 3 closure variables keep track of the first scrape when running the iterator.
	// This allows us to keep track of how many iterations or how long (timewise) we've been running for.
	// All calculations are performed relative to the first detected scrape.
	var firstScrapeHappened bool
	var firstIterationCount int
	var firstScrapeTime time.Time

	// We might never return a single sample if LengthDuration is less than the time it took to scrape for the first
	// time.
	return func(scrapeInfo series.ScrapeInfo) series.ScrapeResult {
		firstScrapeInProgress := false

		// Is this the first scrape?
		if !firstScrapeHappened {
			firstScrapeInProgress = true
			firstScrapeHappened = true
			firstIterationCount = scrapeInfo.IterationCount
			firstScrapeTime = scrapeInfo.IterationTime
		}

		// Normalize
		currentIterationCount := scrapeInfo.IterationCount - firstIterationCount
		currentElapsedTime := scrapeInfo.IterationTime.Sub(firstScrapeTime)

		// Have we reached the end?
		if options.LengthIterationCount != 0 && currentIterationCount >= options.LengthIterationCount {
			return series.ScrapeResult{Value: 0, Missing: false, Exhausted: true}
		} else if options.LengthDuration != 0 {
			if options.LengthDurationExclusive {
				if currentElapsedTime >= options.LengthDuration {
					return series.ScrapeResult{Value: 0, Missing: false, Exhausted: true}
				}
			} else {
				if currentElapsedTime > options.LengthDuration {
					return series.ScrapeResult{Value: 0, Missing: false, Exhausted: true}
				}
			}
		}

		// If this is the first scrape, return the AmplitudeStart
		if firstScrapeInProgress {
			return series.ScrapeResult{Value: options.AmplitudeStart, Missing: false, Exhausted: false}
		}

		// If we have a horizontal line, there is no need to do any computation
		if options.AmplitudeStart == options.AmplitudeEnd {
			return series.ScrapeResult{Value: options.AmplitudeStart, Missing: false, Exhausted: false}
		}

		if options.LengthIterationCount != 0 { // perform calculations based on iteration count
			slope := (options.AmplitudeEnd - options.AmplitudeStart + 1) / (float64(options.LengthIterationCount))
			value := options.AmplitudeStart + slope*float64(currentIterationCount)
			return series.ScrapeResult{Value: value, Missing: false, Exhausted: false}
		} else if options.LengthDuration != 0 { // perform calculations based on elapsed time
			slope := (options.AmplitudeEnd - options.AmplitudeStart) / (float64(options.LengthDuration))
			value := options.AmplitudeStart + slope*float64(currentElapsedTime)
			return series.ScrapeResult{Value: value, Missing: false, Exhausted: false}
		} else {
			// This should never happen as we double check in the validation phase, but in any case we set the sample
			// as missing.
			return series.ScrapeResult{Value: 0, Missing: true, Exhausted: false}
		}
	}, nil
}

// LinearSegmentDataIteratorOptions contains the options for the LinearSegmentDataIterator.
// Either the LengthIterationCount or the LengthDuration fields must be set.
// It's an error to not set one and only one of those fields.
type LinearSegmentDataIteratorOptions struct {
	// AmplitudeStart represents the initial value for the segment.
	AmplitudeStart float64
	// AmplitudeEnd represents the end value for the segment.
	AmplitudeEnd float64

	// LengthIterationCount sets the number of iterations to be used by the segment.
	LengthIterationCount int

	// LengthDuration sets the max duration between the first and the last value.
	LengthDuration time.Duration

	// LengthDurationExclusive sets the LengthDuration to be exclusive.
	// This means that the range is inclusive on the end time.
	// It's an error to set this field without using LengthDuration.
	LengthDurationExclusive bool
}
